<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>地形生成器（原逻辑+海洋透明）</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            background-color: #1a1a1a;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            color: #fff;
            font-family: 'Arial', sans-serif;
        }
        canvas {
            border: 2px solid #444;
            box-shadow: 0 0 15px rgba(0,0,0,0.5);
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }
        .controls {
            margin-top: 20px;
            display: flex;
            gap: 15px;
            align-items: center;
            flex-wrap: wrap;
            justify-content: center;
        }
        button {
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            background-color: #2ecc71;
            color: #fff;
            cursor: pointer;
            font-size: 14px;
            transition: background 0.2s;
        }
        button:hover {
            background-color: #27ae60;
        }
        .seed-group {
            display: flex;
            gap: 8px;
            align-items: center;
        }
        input {
            padding: 10px;
            border-radius: 5px;
            border: none;
            width: 200px;
        }
        .legend {
            display: flex;
            gap: 10px;
            align-items: center;
            font-size: 12px;
            flex-wrap: wrap;
            justify-content: center;
            margin-top: 20px;
        }
        .legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
            margin: 0 5px;
        }
        .color-block {
            width: 20px;
            height: 20px;
            border-radius: 2px;
        }
    </style>
</head>
<body>
    <h1>地形生成器（海洋透明版）</h1>
    <canvas id="terrainCanvas" width="1000" height="700"></canvas>
    <div class="controls">
        <button id="regenerateBtn">重新生成地形</button>
        <button id="saveOriginalBtn">保存原地形图片</button>
        <button id="saveTransparentBtn">保存海洋透明图片</button>
        <div class="seed-group">
            <input type="text" id="seedInput" placeholder="输入种子（如666888）">
        </div>
    </div>
    <div class="legend">
        <div class="legend-item"><div class="color-block" style="background: transparent; border:1px solid #fff;"></div><span>海洋（透明，保存后生效）</span></div>
        <div class="legend-item"><div class="color-block" style="background: #f5f5dc;"></div><span>沙滩</span></div>
        <div class="legend-item"><div class="color-block" style="background: #228B22;"></div><span>平原</span></div>
        <div class="legend-item"><div class="color-block" style="background: #90EE90;"></div><span>丘陵</span></div>
        <div class="legend-item"><div class="color-block" style="background: #006400;"></div><span>高山</span></div>
        <div class="legend-item"><div class="color-block" style="background: #808080;"></div><span>山峰</span></div>
    </div>

    <script>
        // 原文件 ImprovedSimplexNoise 类完全保留，无任何修改
        class ImprovedSimplexNoise {
            constructor(seed = Math.random()) {
                this.seed = seed;
                this.perm = new Array(512);
                this.p = [151,160,137,91,90,15,131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,
                    8,99,37,240,21,10,23,190,6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,
                    32,57,177,33,88,237,149,56,87,174,20,125,136,171,168,68,175,74,165,71,134,139,48,27,
                    166,77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244,102,
                    143,54,65,25,63,161,1,216,80,73,209,76,132,187,208,89,18,169,200,196,135,130,116,188,
                    159,86,164,100,109,198,173,186,3,64,52,217,226,250,124,123,5,202,38,147,118,126,255,
                    82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,223,183,170,213,119,248,152,2,44,
                    154,163,70,221,153,101,155,167,43,172,9,129,22,39,253,19,98,108,110,79,113,224,232,
                    178,185,112,104,218,246,97,228,251,34,242,193,238,210,144,12,191,179,162,241,81,51,
                    145,235,249,14,239,107,49,192,214,31,181,199,106,157,184,84,204,176,115,121,50,45,127,
                    4,150,254,138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180];
                for (let i = 0; i < 256; i++) {
                    this.perm[i] = this.p[Math.floor((i + this.seed * 10000) % 256)];
                    this.perm[256 + i] = this.perm[i];
                }
            }
            fade(t) { return t * t * t * (t * (t * 6 - 15) + 10); }
            lerp(a, b, t) { return a + t * (b - a); }
            grad(hash, x, y) {
                const h = hash & 15; const u = h < 8 ? x : y; const v = h < 4 ? y : h === 12 || h === 14 ? x : 0;
                return ((h & 1) === 0 ? u : -u)+((h & 2) === 0 ? v : -v);
            }
            noise(x, y) {
                const X = Math.floor(x) & 255; const Y = Math.floor(y) & 255; x -= Math.floor(x); y -= Math.floor(y);
                const u = this.fade(x); const v = this.fade(y); const A = this.perm[X] + Y; const B = this.perm[X + 1] + Y;
                return this.lerp(this.lerp(this.grad(this.perm[A], x, y), this.grad(this.perm[B], x - 1, y), u), this.lerp(this.grad(this.perm[A + 1], x, y - 1), this.grad(this.perm[B + 1], x - 1, y - 1), u), v);
            }
            fractalNoise(x, y, octaves = 8, persistence = 0.5, lacunarity = 2.0) {
                let total = 0, amplitude = 1, frequency = 1, maxValue = 0;
                for (let i = 0; i < octaves; i++) { total += this.noise(x * frequency, y * frequency) * amplitude; maxValue += amplitude; amplitude *= persistence; frequency *= lacunarity; }
                return total / maxValue;
            }
        }

        // 原文件所有变量、函数完全保留，无任何修改
        const canvas = document.getElementById('terrainCanvas');
        const ctx = canvas.getContext('2d');
        const regenerateBtn = document.getElementById('regenerateBtn');
        const saveOriginalBtn = document.getElementById('saveOriginalBtn');
        const saveTransparentBtn = document.getElementById('saveTransparentBtn');
        const seedInput = document.getElementById('seedInput');
        let seed, scale, landRatio, octaves, persistence;
        let imageData;
        const mapWidth = canvas.width;
        const mapHeight = canvas.height;
        const baseTerrainColors = {
            deepOcean: {r:0, g:38, b:153},
            shallowOcean: {r:0, g:102, b:255},
            sand: {r:245, g:245, b:220},
            plain: {r:34, g:139, b:34},
            hill: {r:144, g:238, b:144},
            mountain: {r:0, g:100, b:0},
            peak: {r:128, g:128, b:128}
        };

        function fixedSeededRandom(baseSeed, offset, min, max) {
            const s = baseSeed + offset * 1000; const x = Math.sin(s)*10000;
            return min + (x - Math.floor(x))*(max - min);
        }

        function getTerrainColor(value) {
            const norm = (value + 1)/2;
            const oceanThreshold = 0.5-(landRatio - 0.4)*0.2;
            if (norm < oceanThreshold - 0.05) return baseTerrainColors.deepOcean;
            else if (norm < oceanThreshold) return interpolateColor(baseTerrainColors.deepOcean, baseTerrainColors.shallowOcean, (norm - (oceanThreshold - 0.05))/0.05);
            else if (norm < oceanThreshold + 0.03) return interpolateColor(baseTerrainColors.shallowOcean, baseTerrainColors.sand, (norm - oceanThreshold)/0.03);
            else if (norm < oceanThreshold + 0.08) return baseTerrainColors.plain;
            else if (norm < oceanThreshold + 0.15) return interpolateColor(baseTerrainColors.plain, baseTerrainColors.hill, (norm - (oceanThreshold + 0.08))/0.07);
            else if (norm < oceanThreshold + 0.25) return interpolateColor(baseTerrainColors.hill, baseTerrainColors.mountain, (norm - (oceanThreshold + 0.15))/0.1);
            else return baseTerrainColors.peak;
        }

        function interpolateColor(c1, c2, t) {
            t = Math.pow(t, 1.2);
            return { r: Math.floor(c1.r + (c2.r - c1.r) * t), g: Math.floor(c1.g + (c2.g - c1.g) * t), b: Math.floor(c1.b + (c2.b - c1.b) * t) };
        }

        function setPixel(x, y, color) {
            if (x < 0 || x >= mapWidth || y < 0 || y >= mapHeight) return;
            const index = (y * mapWidth + x)*4;
            imageData.data[index] = color.r;
            imageData.data[index + 1] = color.g;
            imageData.data[index + 2] = color.b;
            imageData.data[index + 3] = 255;
        }

        function initParamsBySeed(importedSeed = null) {
            seed = importedSeed !== null ? importedSeed : Math.floor(Math.random()*1000000);
            scale = fixedSeededRandom(seed, 1, 0.005, 0.008);
            landRatio = fixedSeededRandom(seed, 2, 0.45, 0.6);
            octaves = Math.floor(fixedSeededRandom(seed, 3, 6, 8));
            persistence = fixedSeededRandom(seed, 4, 0.5, 0.7);
            seedInput.value = seed;
        }

        function generateTerrain(importedSeed = null) {
            initParamsBySeed(importedSeed);
            const noiseGenerator = new ImprovedSimplexNoise(seed);
            imageData = ctx.createImageData(mapWidth, mapHeight);
            for (let y = 0; y < mapHeight; y++) {
                for (let x = 0; x < mapWidth; x++) {
                    const noiseValue = noiseGenerator.fractalNoise(x * scale, y * scale, octaves, persistence);
                    const color = getTerrainColor(noiseValue);
                    setPixel(x, y, color);
                }
            }
            ctx.putImageData(imageData, 0, 0);
        }

        // 原保存功能完全保留
        function saveMapAsImage() {
            const link = document.createElement('a');
            link.download = `mc_terrain_seed_${seed}.png`;
            link.href = canvas.toDataURL('image/png');
            link.click();
        }

        // 新增：保存海洋透明图片（仅修改海洋像素的Alpha值为0）
        function saveTransparentOceanMap() {
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = mapWidth;
            tempCanvas.height = mapHeight;
            const tempCtx = tempCanvas.getContext('2d');
            tempCtx.putImageData(imageData, 0, 0); // 复制原地形像素数据
            const tempImageData = tempCtx.getImageData(0, 0, mapWidth, mapHeight);
            const tempData = tempImageData.data;

            // 遍历像素，判断是否为海洋（深海/浅海），设为透明
            for (let y = 0; y < mapHeight; y++) {
                for (let x = 0; x < mapWidth; x++) {
                    const index = (y * mapWidth + x) * 4;
                    const r = tempData[index];
                    const g = tempData[index + 1];
                    const b = tempData[index + 2];

                    // 匹配深海或浅海颜色（严格按原baseTerrainColors）
                    const isDeepOcean = r === baseTerrainColors.deepOcean.r && g === baseTerrainColors.deepOcean.g && b === baseTerrainColors.deepOcean.b;
                    const isShallowOcean = r === baseTerrainColors.shallowOcean.r && g === baseTerrainColors.shallowOcean.g && b === baseTerrainColors.shallowOcean.b;

                    if (isDeepOcean || isShallowOcean) {
                        tempData[index + 3] = 0; // 海洋设为透明（Alpha=0）
                    }
                    // 陆地像素保持原样，不做任何修改
                }
            }

            tempCtx.putImageData(tempImageData, 0, 0);
            const link = document.createElement('a');
            link.download = `terrain_transparent_ocean_seed_${seed}.png`;
            link.href = tempCanvas.toDataURL('image/png');
            link.click();
        }

        // 原事件绑定完全保留，仅新增透明保存按钮事件
        let inputTimer = null;
        seedInput.addEventListener('input', () => {
            clearTimeout(inputTimer);
            inputTimer = setTimeout(() => {
                const inputSeed = parseInt(seedInput.value);
                if (!isNaN(inputSeed) && inputSeed > 0) generateTerrain(inputSeed);
            }, 300);
        });

        regenerateBtn.addEventListener('click', () => generateTerrain());
        saveOriginalBtn.addEventListener('click', saveMapAsImage);
        saveTransparentBtn.addEventListener('click', saveTransparentOceanMap); // 新增事件

        generateTerrain();
    </script>
</body>
</html>