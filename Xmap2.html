<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>大海洋随机地形（种子绝对一致版）</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            background-color: #1a1a1a;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            color: #fff;
            font-family: 'Arial', sans-serif;
        }
        canvas {
            border: 2px solid #444;
            box-shadow: 0 0 15px rgba(0,0,0,0.5);
        }
        .controls {
            margin-top: 20px;
            display: flex;
            gap: 15px;
            align-items: center;
            flex-wrap: wrap;
            justify-content: center;
        }
        button {
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            background-color: #2ecc71;
            color: #fff;
            cursor: pointer;
            font-size: 14px;
            transition: background 0.2s;
        }
        button:hover {
            background-color: #27ae60;
        }
        .seed-group {
            display: flex;
            gap: 8px;
            align-items: center;
        }
        input {
            padding: 10px;
            border-radius: 5px;
            border: none;
            width: 200px;
        }
        .legend {
            display: flex;
            gap: 10px;
            align-items: center;
            font-size: 12px;
            flex-wrap: wrap;
            justify-content: center;
            margin-top: 10px;
        }
        .legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        .color-block {
            width: 20px;
            height: 20px;
            border-radius: 2px;
        }
    </style>
</head>
<body>
    <h1>大海洋随机地形（大陆/海湾/孤岛/群岛）</h1>
    <canvas id="terrainCanvas" width="1000" height="700"></canvas>
    <div class="controls">
        <button id="regenerateBtn">重新生成地形</button>
        <button id="saveMapBtn">保存当前地图</button>
        <div class="seed-group">
            <input type="text" id="seedInput" placeholder="输入种子立刻生成地形">
        </div>
    </div>
    <div class="legend">
        <div class="legend-item">
            <div class="color-block" style="background: #002699;"></div>
            <span>深海</span>
        </div>
        <div class="legend-item">
            <div class="color-block" style="background: #0066ff;"></div>
            <span>浅海</span>
        </div>
        <div class="legend-item">
            <div class="color-block" style="background: #f5f5dc;"></div>
            <span>沙滩</span>
        </div>
        <div class="legend-item">
            <div class="color-block" style="background: #90EE90;"></div>
            <span>平原</span>
        </div>
        <div class="legend-item">
            <div class="color-block" style="background: #228B22;"></div>
            <span>丘陵</span>
        </div>
        <div class="legend-item">
            <div class="color-block" style="background: #006400;"></div>
            <span>高山</span>
        </div>
        <div class="legend-item">
            <div class="color-block" style="background: #808080;"></div>
            <span>山峰</span>
        </div>
    </div>

    <script>
        class ImprovedSimplexNoise {
            constructor(seed = Math.random()) {
                this.seed = seed;
                this.perm = new Array(512);
                this.p = [151,160,137,91,90,15,131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,
                    8,99,37,240,21,10,23,190,6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,
                    32,57,177,33,88,237,149,56,87,174,20,125,136,171,168,68,175,74,165,71,134,139,48,27,
                    166,77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244,102,
                    143,54,65,25,63,161,1,216,80,73,209,76,132,187,208,89,18,169,200,196,135,130,116,188,
                    159,86,164,100,109,198,173,186,3,64,52,217,226,250,124,123,5,202,38,147,118,126,255,
                    82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,223,183,170,213,119,248,152,2,44,
                    154,163,70,221,153,101,155,167,43,172,9,129,22,39,253,19,98,108,110,79,113,224,232,
                    178,185,112,104,218,246,97,228,251,34,242,193,238,210,144,12,191,179,162,241,81,51,
                    145,235,249,14,239,107,49,192,214,31,181,199,106,157,184,84,204,176,115,121,50,45,127,
                    4,150,254,138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180];
                
                for (let i = 0; i < 256; i++) {
                    this.perm[i] = this.p[Math.floor((i + this.seed * 10000) % 256)];
                    this.perm[256 + i] = this.perm[i];
                }
            }

            fade(t) { return t * t * t * (t * (t * 6 - 15) + 10); }
            lerp(a, b, t) { return a + t * (b - a); }
            grad(hash, x, y) {
                const h = hash & 15;
                const u = h < 8 ? x : y;
                const v = h < 4 ? y : h === 12 || h === 14 ? x : 0;
                return ((h & 1) === 0 ? u : -u) + ((h & 2) === 0 ? v : -v);
            }

            noise(x, y) {
                const X = Math.floor(x) & 255;
                const Y = Math.floor(y) & 255;
                x -= Math.floor(x);
                y -= Math.floor(y);
                const u = this.fade(x);
                const v = this.fade(y);
                const A = this.perm[X] + Y;
                const B = this.perm[X + 1] + Y;

                return this.lerp(
                    this.lerp(this.grad(this.perm[A], x, y), this.grad(this.perm[B], x - 1, y), u),
                    this.lerp(this.grad(this.perm[A + 1], x, y - 1), this.grad(this.perm[B + 1], x - 1, y - 1), u),
                    v
                );
            }

            fractalNoise(x, y, octaves = 8, persistence = 0.5, lacunarity = 2.0) {
                let total = 0;
                let amplitude = 1;
                let frequency = 1;
                let maxValue = 0;

                for (let i = 0; i < octaves; i++) {
                    total += this.noise(x * frequency, y * frequency) * amplitude;
                    maxValue += amplitude;
                    amplitude *= persistence;
                    frequency *= lacunarity;
                }

                return total / maxValue;
            }
        }

        const canvas = document.getElementById('terrainCanvas');
        const ctx = canvas.getContext('2d');
        const regenerateBtn = document.getElementById('regenerateBtn');
        const saveMapBtn = document.getElementById('saveMapBtn');
        const seedInput = document.getElementById('seedInput');

        let seed, scale, landRatio, octaves, persistence;

        // 彻底固化的种子随机函数：输入种子+偏移量，输出固定值
        function fixedSeededRandom(baseSeed, offset, min, max) {
            const seed = baseSeed + offset * 1000;
            const x = Math.sin(seed) * 10000;
            const frac = x - Math.floor(x);
            return min + frac * (max - min);
        }

        // 初始化参数：用固定偏移量派生参数，完全绑定种子
        function initParamsBySeed(importedSeed = null) {
            seed = importedSeed !== null ? importedSeed : Math.random() * 1000000;
            // 每个参数用唯一固定偏移量，确保序列绝对一致
            scale = fixedSeededRandom(seed, 1, 0.004, 0.007);
            landRatio = fixedSeededRandom(seed, 2, 0.2, 0.4);
            octaves = Math.floor(fixedSeededRandom(seed, 3, 6, 10));
            persistence = fixedSeededRandom(seed, 4, 0.4, 0.6);
            seedInput.value = seed.toFixed(0); // 种子取整，减少输入误差
        }

        function getTerrainColor(value) {
            const norm = (value + 1) / 2;
            const oceanThreshold = 0.45 + (landRatio - 0.3) * 0.1;

            if (norm < oceanThreshold - 0.15) {
                const deepBlue = 153 - Math.floor(norm / (oceanThreshold - 0.15) * 93);
                return { r: 0, g: 0, b: deepBlue };
            } else if (norm < oceanThreshold) {
                const shallowBlue = Math.floor((norm - (oceanThreshold - 0.15)) / 0.15 * 102) + 153;
                return { r: 0, g: 102, b: shallowBlue };
            } else if (norm < oceanThreshold + 0.03) {
                const sand = Math.floor((norm - oceanThreshold) / 0.03 * 40) + 215;
                return { r: sand, g: sand, b: 200 };
            } else if (norm < oceanThreshold + 0.15) {
                const green = Math.floor((norm - (oceanThreshold + 0.03)) / 0.12 * 80) + 170;
                return { r: 100, g: green, b: 100 };
            } else if (norm < oceanThreshold + 0.3) {
                const hillGreen = 170 - Math.floor((norm - (oceanThreshold + 0.15)) / 0.15 * 70);
                return { r: 0, g: 100 + hillGreen, b: 0 };
            } else if (norm < oceanThreshold + 0.45) {
                const mountainGreen = 100 - Math.floor((norm - (oceanThreshold + 0.3)) / 0.15 * 100);
                return { r: 0, g: mountainGreen, b: 0 };
            } else {
                const peakGray = 120 - Math.floor((norm - (oceanThreshold + 0.45)) / 0.55 * 120);
                return { r: peakGray, g: peakGray, b: peakGray };
            }
        }

        function generateTerrain(importedSeed = null) {
            initParamsBySeed(importedSeed);
            const noiseGenerator = new ImprovedSimplexNoise(seed);
            const width = canvas.width;
            const height = canvas.height;
            const imageData = ctx.createImageData(width, height);
            const data = imageData.data;

            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const noiseValue = noiseGenerator.fractalNoise(x * scale, y * scale, octaves, persistence);
                    const color = getTerrainColor(noiseValue);
                    const index = (y * width + x) * 4;
                    data[index] = color.r;
                    data[index + 1] = color.g;
                    data[index + 2] = color.b;
                    data[index + 3] = 255;
                }
            }

            ctx.putImageData(imageData, 0, 0);
        }

        function saveMapAsImage() {
            const link = document.createElement('a');
            link.download = `mc_terrain_seed_${seed}.png`;
            link.href = canvas.toDataURL('image/png');
            link.click();
        }

        // 防抖输入：避免输入过程中频繁生成
        let inputTimer = null;
        seedInput.addEventListener('input', () => {
            clearTimeout(inputTimer);
            inputTimer = setTimeout(() => {
                const inputSeed = parseFloat(seedInput.value);
                if (!isNaN(inputSeed) && inputSeed > 0) {
                    generateTerrain(inputSeed);
                }
            }, 300);
        });

        regenerateBtn.addEventListener('click', () => generateTerrain());
        saveMapBtn.addEventListener('click', saveMapAsImage);

        generateTerrain();
    </script>
</body>
</html>